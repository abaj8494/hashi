# Hashi Puzzle Solver in Go

This project is a Go implementation of a solver for the Hashi (Bridges) puzzle game. It includes a command-line interface and comprehensive testing framework that leverages the existing C implementation tools.

## Overview

Hashi (æ©‹) is a logic puzzle with simple rules but complex solutions:
- The puzzle consists of islands (numbered circles) on a grid
- The goal is to connect islands with bridges (horizontal or vertical lines)
- Each island must have exactly the number of bridges indicated by its number
- Bridges cannot cross each other
- All islands must be connected into a single network

## Components

This project includes:

1. **solver.go**: Go implementation of the Hashi puzzle solver, refactored from the original C code
2. **main.go**: Command-line interface to use the solver
3. **Testing framework**:
   - **solver_test.go**: Tests the solver against puzzles generated by bridgen.c
   - **benchmark_test.go**: Performance benchmarks for the solver

## Original C Components (Used for Testing)

1. **bridgen.c**: Generates random Hashi puzzles
2. **bridgecheck.c**: Validates solutions to Hashi puzzles

## Usage

### Solving Puzzles

```bash
# Solve a puzzle from stdin
cat puzzle.txt | go run main.go

# Solve a puzzle from a file
go run main.go -input puzzle.txt

# Enable debug output
go run main.go -input puzzle.txt -debug
```

### Running Tests

```bash
# Run all tests
go test

# Run tests with verbose output
go test -v

# Run a specific test
go test -run TestSolverWithKnownPuzzles

# Run benchmarks
go test -bench=.
```

## Test Framework

The testing framework includes:

1. **Regression Tests**: Tests against puzzles of various sizes (up to 20x20) generated by bridgen.c
2. **Known Puzzle Tests**: Tests against puzzles with known solutions
3. **Performance Benchmarks**: Measures solver performance and memory usage on different board sizes
4. **Heuristic Analysis**: Compares solving performance with and without using heuristics

## Implementation Details

The solver uses a combination of strategies:

1. **Heuristics**: Applies logical rules to make initial bridge placements
2. **Backtracking**: Uses depth-first search with backtracking to explore possible solutions
3. **Forward Checking**: Prunes the search space by checking if a partial solution can be completed

The implementation is designed to be both efficient and maintainable, with a clear separation of concerns between data structures, algorithms, and I/O handling.

## Data Structures

- **Island**: Represents a puzzle island with its coordinates, bridge count, and neighbors
- **Bridge**: Represents a connection between two islands
- **Puzzle**: Represents the entire puzzle state

## Performance Considerations

The solver is optimized for:

1. **Memory efficiency**: Uses fixed-size arrays where possible
2. **Speed**: Implements heuristics to reduce the search space
3. **Correctness**: Extensively tested against both generated and known puzzles

## License

This code is provided as-is with no warranty. The original C code was provided for reference and testing purposes. 